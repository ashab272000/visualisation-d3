<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Covid 19 Viewer</title>
    <script src='https://d3js.org/d3.v7.min.js'></script>

</head>

<style>
    #countries {
        width: 150px;
        height: calc(100vh - 66px);
        position: fixed;
        background-color: #1e1e1e;
    }

    #container {
        display: flex;
        width: inherit;
        height: inherit;
        justify-content: center;
        flex-wrap: wrap;
    }

    #container div {
        width: 500px;
    }
</style>

<body style="display: flex;">

    <div id="countries">

    </div>
    <div id="container" style="display: flex;">
        <div id="map__container">
            <!-- <svg id="map" width="400" height="300"></svg> -->
            <svg id="map"></svg>
            <div style="display: flex;">
                <div>
                    <label for="map__select">Display:</label>

                    <select name="map__select" id="map__select">
                        <option value="total_cases">Cases</option>
                        <option value="total_tests">Tests</option>
                        <option value="total_deaths">Deaths</option>
                        <option value="total_vaccinations">Vaccinations</option>
                        <!-- <option value="total_vaccinations">Vaccinations</option> -->
                    </select>
                </div>
                <div>
                    <label for="map__by__select">By:</label>

                    <select name="map__by__select" id="map__by__select">
                        <option value="number">Number</option>
                        <option value="percentage">Percentage Of Population</option>
                    </select>
                </div>
            </div>
        </div>
        <!-- <div id="pie__container">
                <svg id="pie" width="400" height="300"></svg>
            </div> -->
        <div id="line__container">
            <div id="line__chart__container">
            </div>
            <label for="line__select1">Line 1:</label>

            <select name="line__select1" id="line__select1">
                <option value="new_cases">New Cases</option>
                <option value="new_deaths">New Deaths</option>
                <option value="people_vaccinated">People Vaccinated</option>
            </select>
            <label for="line__select2">Line 2:</label>

            <select name="line__select2" id="line__select2">
                <option value="people_vaccinated">People Vaccinated</option>
                <option value="new_cases">New Cases</option>
                <option value="new_deaths">New Deaths</option>
            </select>
        </div>
        <div id='line2__container'>
            <div id="line2__chart__container">
            </div>
            <label for="line2__chart__container__select1">Y:</label>

            <select name="line2__chart__container__select1" id="line2__chart__container__select1">
                <option value="new_cases_smoothed">New Cases</option>
                <option value="new_deaths_smoothed">New Deaths</option>
                <option value="new_vaccinations_smoothed">New Vaccinated</option>
                <option value="total_vaccinations">Total Vaccinated</option>
                <option value="total_deaths">Total Deaths</option>
                <option value="total_cases">Total Cases</option>
            </select>

            <label for="line2__chart__container__select2">Divided By:</label>

            <select name="line2__chart__container__select2" id="line2__chart__container__select2">
                <option value="1">1</option>
                <option value="population">Population</option>
            </select>
        </div>
        <div id="scatter__container">
            <div id="scatter__chart__container">
            </div>
            <label for="scatter_select">Y Value: </label>

            <select name="scatter_select" id="scatter_select">
                <option value="total_vaccinations">Total Vaccinations (millions)</option>
                <option value="total_cases">Total Cases (millions)</option>
                <option value="total_deaths">Total Deaths (millions)</option>
            </select>
        </div>
    </div>
    <script>
        (async () => {
            // Global Values
            const selectedCountries = []
            const colorScale = d3.scaleOrdinal().range(d3.schemeSet3);
            // ---------------------------------
            // ---------------------------------Line Chart values---------------------------------
            // ---------------------------------

            const margin = { top: 50, right: 150, bottom: 50, left: 150 };

            // ---------------------------------
            // ---------------------------------Scatter values---------------------------------
            // ---------------------------------

            scatterContainerWidth = 400
            scatterContainerHeight = 300

            // ---------------------------------
            // ---------------------------------Map values---------------------------------
            // ---------------------------------
            const mapSvg = d3.select("#map")
            mapWidth = 400
            mapHeight = 300


            // Setting background of Map
            mapSvg.style('background', '#1e1e1e')
            const path = d3.geoPath();
            const projection = d3.geoMercator()
                .scale(70)
                .center([0, 20])
                .translate([mapWidth / 2, mapHeight / 2]);


            const loadDataset = async () => {
                const topoData = await d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson");

                console.log('Loaded topo data')
                const covid = await d3.csv('./data/owid-covid-data.csv', (d) => {
                    // TODO:
                    d.dateString = d.date
                    d.date = d3.timeParse("%Y-%m-%d")(d.date);
                    d.total_vaccinations_per_million = d.total_vaccinations / 1000000
                    return d
                });
                // console.log(covid[0])
                console.log('Loaded covid data')

                return [covid, topoData]
            }
            const allData = await loadDataset()
            const dataset = allData[0]
            const topoData = allData[1]
            const countries = {}
            topoData.features.forEach(e => { countries[e.id] = e.properties.name })
            // Modified dataset to select data by country
            const dataByCountry = {}

            for (let i = 0; i < dataset.length; i++) {
                try {
                    dataByCountry[dataset[i]['iso_code']].push(dataset[i])

                } catch (error) {
                    dataByCountry[dataset[i]['iso_code']] = [dataset[i]]

                }
            }
            const updateCountries = () => {
                const main = d3
                    .select('#countries')
                    .selectAll('div.country')
                    .data(selectedCountries)

                const divs = main
                    .enter()
                    .append('div')
                    .attr('class', 'country')
                    .style('display', 'flex')
                    .style('justify-content', 'space-between')
                    .style('align-items', 'center')
                    .style('height', '22px')
                    .style('padding', '0px 8px')

                divs
                    .append('p')
                    .style('color', 'white')
                    .text((d) => countries[d])

                divs
                    .append('div')
                    .style('width', '20px')
                    .style('height', '5px')
                    .style('background', (d, i) => colorScale(i))

                const merged = divs
                    .merge(main)

                merged
                    .select('p')
                    .text(d => countries[d])

                merged.select('div').style('background', (d, i) => colorScale(i))

                main.exit()
                    .remove()
            }

            const countryCodes = topoData.features.map((e) => e.id)

            const getTotalsByCountry = ({ date = null, key = 'total_cases' }) => {
                const data = []
                for (let i = 0; i < countryCodes.length; i++) {
                    let filtered = dataset.filter((e) => { return e['iso_code'] == countryCodes[i] })
                    if (filtered.length == 0) {
                        continue
                    }

                    if (date == null) {
                        let value = 0
                        let gdp = 0
                        let pop = filtered[0]['population']
                        for (let j = filtered.length - 1; j >= 0; j--) {
                            value = filtered[j][key]

                            if (parseInt(value) > 0) {
                                value = parseInt(value)
                                gdp = filtered[j]['gdp_per_capita']
                                break;
                            }
                        }
                        data.push({ 'id': countryCodes[i], 'value': value, 'pop': pop, 'gdp': gdp })
                    }

                }
                return data

            }
            // const totalCases = getTotalCasesByCountry()
            let mapColorScale = d3.scaleSequential().domain([0, 50000000]).interpolator(d3.interpolateBlues);
            // console.log(dataset)
            const getMapValues = () => {
                const key = d3.select('#map__select').property("value")
                const byKey = d3.select('#map__by__select').property("value")
                // console.log(value)
                const totals = getTotalsByCountry({ key })
                let values = []
                if (byKey == 'percentage') {
                    totals.forEach(e => { e.value = e.value / e.pop })
                }
                values = totals.map(e => e.value)

                mapColorScale = d3.scaleSequential().domain([d3.quantile(values, .05), d3.quantile(values, 0.95)]).interpolator(d3.interpolateBlues);

                mapSvg.attr("preserveAspectRatio", "xMinYMin meet")
                    .attr("viewBox", `0 0 ${mapWidth} ${mapHeight}`)

                return totals
            }

            const onMapSelectChange = () => {
                const totals = getMapValues()
                mapSvg
                    .select('g')
                    .selectAll('path')
                    .attr("fill", function (d) {

                        const scale = totals.find(e => { return e.id == d.id })
                        return mapColorScale(scale ? scale.value : 0)
                    })
            }

            const createMap = async () => {

                function onClick(e, d) {
                    let index = selectedCountries.findIndex(element => element == d.id)
                    if (index != -1) {
                        selectedCountries.splice(index, 1)
                        d3.select(this).attr('stroke', 'transparent')
                    } else {
                        d3.select(this).attr('stroke', colorScale(selectedCountries.length)).attr('stroke-width', 1.5)
                        selectedCountries.push(d.id)
                    }
                    updateCountries()
                    updateCountriesLineChart2()
                    // console.log(selectedCountries);
                }

                const values = getMapValues()

                mapSvg.append("g")
                    .selectAll("path")
                    .data(topoData.features)
                    .join("path")
                    // draw each country
                    .attr("d", d3.geoPath()
                        .projection(projection)
                    )
                    // set the color of each country by a certain selected value
                    .attr("fill", function (d) {

                        // d.total = dataset[d.id] || 0;
                        const scale = values.find(e => { return e.id == d.id })
                        return mapColorScale(scale ? scale.value : 0)
                    })
                    .on('click', onClick)
            }

            // TODO: Create Pie Chart
            const createPie = async () => {
                const svg = d3.select('#pie').append("g").attr("transform", `translate(${pieSvgWidth / 2},${pieSvgHeight / 2})`);
                // const data = getTotalsByCountry({ key:  })
                var path = svg
                    .selectAll(".pie-chart")
                    .append('g')
                    .attr("class", 'pie-chart')
                    .data((d) => {
                        return pie(data)
                    })
                    .enter()
                    .append("path")
                    .transition()
                    .ease(d3.easeLinear)
                    .duration((d) => {
                        return ((d.endAngle - d.startAngle) / Math.PI) * 1000
                    })
                    .delay((d) => {
                        return ((d.startAngle / Math.PI) * 1000)
                    })
                    .attr('d', arc)
                    .attr("fill", function (d, i) { return color(i); })
                    .attrTween("d", function (d, i, n) {
                        // console.log("arctween")
                        // console.log(d.startAngle)
                        // console.log(d.endAngle)
                        var i = d3.interpolate(d.startAngle, d.endAngle);
                        return function (t) {
                            d.endAngle = i(t);
                            return arc(d);
                        }
                    })

            }

            const createChart = async ({ chartWidth = 400, chartHeight = 300, data, parentId, xScale, yScale, y2Scale, xLabel, y1Label, y2Label, x, y, y2, chart1, chart2 }) => {
                // got the dataset
                // got the dimensions
                const textMargin = 30
                const chartMargin = { left: 0, right: 0, top: 60, bottom: 0 }
                const svg = d3.select(`#${parentId}`)
                    .append("svg")
                    .attr("preserveAspectRatio", "xMinYMin meet")
                    .attr("viewBox", `0 0 ${chartWidth} ${chartHeight}`)
                    .append("g")
                    .attr("id", `${parentId}__svg`)

                // got the x and y scaler
                if (y1Label != null) {
                    const text = svg.append("text")
                        .attr("id", `${parentId}__y1label`)
                        // .attr("text-anchor", "end")
                        .attr("x", 0)
                        .attr("y", textMargin / 2)
                        .attr('transform', `rotate(-90)`)
                        .text(y1Label);

                    let textHeight = text.node().getBoundingClientRect().height
                    let textWidth = text.node().getBoundingClientRect().width
                    text.attr("x", -(chartHeight / 2) - textHeight / 3)
                    chartMargin.left += textMargin - textWidth / 2
                }

                if (y2Label != null) {
                    chartMargin.right += textMargin
                    const text = svg.append("text")
                        .attr("id", `${parentId}__y2label`)
                        // .attr("text-anchor", "end")
                        .attr("x", 0)
                        .attr("y", textMargin)
                        .attr('transform', `rotate(-90)`)
                        .text(y2Label);

                    let textHeight = text.node().getBoundingClientRect().height
                    text.attr("x", -(chartHeight / 2) - textHeight / 3).attr('y', chartWidth - (textMargin / 2))

                }

                if (xLabel != null) {
                    chartMargin.bottom += textMargin
                    const text = svg.append("text")
                        .attr("id", `${parentId}__xlabel`)
                        // .attr("text-anchor", "end")
                        .attr("x", 0)
                        .attr("y", chartHeight - textMargin / 2)
                        .text(xLabel);

                    let textWidth = text.node().getBoundingClientRect().width
                    text
                        .attr("x", (chartWidth / 2) - textWidth / 3)
                        .attr('y', chartHeight - (textMargin / 2))

                }

                // Adding X axis
                let xAxis = svg.append("g")
                    .attr('id', `${parentId}__x__axis`)
                    .attr("transform", `translate(${chartMargin.left}, ${chartHeight - chartMargin.bottom})`)
                    .call(d3.axisBottom(xScale));
                let xAxisHeight = xAxis.node().getBoundingClientRect().height

                // Adding Y1 axis
                let y1Axis = svg.append("g")
                    .attr('id', `${parentId}__y1__axis`)
                    .attr("transform", `translate(${chartMargin.left}, ${- chartMargin.bottom})`)
                    .call(d3.axisLeft(yScale));
                let y1AxisWidth = y1Axis.node().getBoundingClientRect().width
                chartMargin.left += y1AxisWidth




                // Adding Y2 axis
                if (y2 != null) {

                    let y2Axis = svg.append("g")
                        .attr('id', `${parentId}__y2__axis`)
                        .attr("transform", `translate(${chartMargin.left + chartWidth}, ${- chartMargin.bottom})`)
                        .call(d3.axisRight(y2Scale));
                    let y2AxisWidth = y2Axis.node().getBoundingClientRect().width
                    chartMargin.right += y2AxisWidth

                }
                let currentWidth = chartWidth - chartMargin.left - chartMargin.right
                let currentHeight = chartHeight - chartMargin.bottom - chartMargin.top
                // Save the current width and height
                svg
                    .attr("viewHeight", currentHeight)
                    .attr("viewWidth", currentWidth)
                // console.log('currentWidth')
                // console.log(currentWidth)
                // console.log('currentHeight')
                // console.log(currentHeight)
                xScale.range([0, currentWidth])
                yScale.range([currentHeight, 0])

                d3.select(`#${parentId}__x__axis`)
                    .attr("transform", `translate(${chartMargin.left}, ${currentHeight - chartMargin.bottom + chartMargin.top})`)
                    .call(d3.axisBottom(xScale))
                d3.select(`#${parentId}__y1__axis`)
                    .attr("transform", `translate(${chartMargin.left}, ${-chartMargin.bottom + chartMargin.top})`)
                    .call(d3.axisLeft(yScale))
                if (y2 != null) {


                    y2Scale.range([currentHeight, 0])
                    d3.select(`#${parentId}__y2__axis`)
                        .attr("transform", `translate(${currentWidth + chartMargin.left}, ${-chartMargin.bottom + chartMargin.top})`)
                        .call(d3.axisRight(y2Scale))
                }

                // Add the values
                let i = 0
                for (i = 0; i < y.length; i++) {
                    // https://css-tricks.com/snippets/javascript/random-hex-color/
                    chart1({ svg, id: `${parentId}__chart${i}`, i, xScale, yScale, x, y, chartMargin })
                    d3.select(`#${parentId}__chart${i}`)
                        .attr('class', 'chart')
                        .attr('marginLeft', chartMargin.left)
                        .attr('marginTop', chartMargin.top)
                        .attr('marginBottom', chartMargin.bottom)
                        .attr('marginRight', chartMargin.right)
                }

                if (y2 != null) {
                    chart2({ svg, id: `${parentId}__chart1000`, i, xScale, y2Scale, x, y2, chartMargin })
                    d3.select(`#${parentId}__chart1000`)
                        .attr('class', 'chart')
                        .attr('marginLeft', chartMargin.left)
                        .attr('marginTop', chartMargin.top)
                        .attr('marginBottom', chartMargin.bottom)
                        .attr('marginRight', chartMargin.right)
                }

            }

            // -------------------------- Creating Line Chart --------------------------
            const createLineChart = async () => {
                const width = 400;
                const height = 300;
                const data = dataset.filter(e => e.iso_code == 'OWID_WRL')
                // Setting up X axis
                var x = d3.scaleTime()
                    .domain(d3.extent(data, function (d) { return d.date; }))
                    .range([0, width]);
                var y1 = d3.scaleLinear()
                    .domain([0, d3.max(data, (d) => +(d.new_vaccinations_smoothed_per_million))])
                    .range([height, 0]);
                // New Cases
                var y2 = d3.scaleLinear()
                    .domain([0, d3.max(data, (d) => +d.new_cases_smoothed_per_million)])
                    .range([height, 0]);

                createChart({
                    chartWidth: width,
                    chartHeight: height,
                    data: data,
                    parentId: 'line__chart__container',
                    xLabel: "Timeline of Covid 19",
                    y1Label: "New Vaccinated(millions)",
                    y2Label: "New Cases(millions)",
                    xScale: x,
                    yScale: y1,
                    y2Scale: y2,
                    x: "date",
                    y: ["new_vaccinations_smoothed_per_million"],
                    y2: "new_cases_smoothed_per_million",
                    chart1: ({ svg, id, i, xScale, yScale, x, y, chartMargin }) => {
                        svg.append("path")
                            .attr('id', id)
                            .datum(data)
                            .attr("fill", "none")
                            .attr("stroke", colorScale(i))
                            .attr("stroke-width", 1.5)
                            .attr("d", d3.line()
                                .x(function (d) { return xScale(d[x]) + chartMargin.left })
                                .y(function (d) { return yScale(d[y[i]]) - chartMargin.bottom + chartMargin.top })
                            )

                    },
                    chart2: ({ svg, id, i, xScale, y2Scale, x, y2, chartMargin }) => {
                        svg.append("path")
                            .attr('id', id)
                            .datum(data)
                            .attr("fill", "none")
                            .attr("stroke", colorScale(i))
                            .attr("stroke-width", 1.5)
                            .attr("d", d3.line()
                                .x(function (d) { return xScale(d[x]) + chartMargin.left })
                                .y(function (d) { return y2Scale(d[y2]) - chartMargin.bottom + chartMargin.top })
                            )

                    }
                })


            }

            const createGdpChart = async () => {
                let data = getTotalsByCountry({ key: 'total_vaccinations_per_million' })
                data = data.filter(d => d.gdp > 0)
                const width = 400;
                const height = 300;
                // Setting up X axis
                let x = d3.scaleLinear()
                    .domain([0, d3.max(data, (d) => +(d.gdp))])
                    .range([0, width]);
                // New Cases
                let y = d3.scaleLinear()
                    .domain([0, d3.max(data, (d) => +(d.value / d.pop))])
                    .range([height, 0]);

                createChart({
                    chartWidth: width,
                    chartHeight: height,
                    data: data,
                    parentId: 'scatter__chart__container',
                    xLabel: "GDP per capita",
                    y1Label: "Total Vaccination(millions)",
                    xScale: x,
                    yScale: y,
                    x: "gdp",
                    y: ["value"],
                    chart1: ({ svg, id, i, xScale, yScale, x, y, chartMargin }) => {
                        // console.log(chartMargin)
                        const chart = svg.append("g")
                            .attr('id', id)

                        chart.call(d3.brush().extent([[0, 0], [width, height]]).on('brush', onBrushGdp))

                        chart
                            .selectAll("dot")
                            .data(data)
                            .enter()
                            .append("circle")
                            .attr("cx", function (d) { return xScale(d[x]) + chartMargin.left; })
                            .attr("cy", function (d) { return yScale(d[y[0]] / d.pop) - chartMargin.bottom + chartMargin.top; })
                            .attr("r", 2)
                            .style("fill", "#69b3a2")
                    },
                })


            }

            const onBrushGdp = (e) => {
                let selection = e.selection
                const chartId = '#scatter__chart__container__chart0'
                selectedCountries.length = 0
                d3.select('#scatter__chart__container__chart0').selectAll('circle').each(function (d) {
                    const dot = d3.select(this)
                    if (dot.attr('class') == 'selected') {
                        dot.attr('class', null)
                    }
                    dot.style('fill', "#69b3a2")
                    const cx = dot.attr('cx')
                    const cy = dot.attr('cy')

                    if (cx > selection[0][0] && cx < selection[1][0] && cy > selection[0][1] && cy < selection[1][1]) {
                        if (selectedCountries.findIndex(e => e == d.id) == -1) {
                            selectedCountries.push(d.id)
                            dot.attr('class', 'selected').style('fill', '#a45fe1')
                            updateCountries()
                            updateCountriesLineChart2()
                        }
                    }
                })
                // console.log(selectedCountries)

            }



            const getMaxCountryData = (isoCodes, yKey, divide) => {
                let maxCountry = null;
                let maxY = 0;
                for (let i = 0; i < isoCodes.length; i++) {
                    let yVal = d3.max(dataByCountry[isoCodes[i]], d => +(d[yKey] / (d[divide] ?? 1)))
                    // console.log(`Country: ${isoCodes[i]}, Y: ${yVal}`)
                    if (yVal > maxY) {
                        maxY = yVal
                        maxCountry = isoCodes[i]
                    }
                }
                return maxCountry
            }

            const createLineChart2 = async () => {
                const width = 400;
                const height = 300;
                const isoCodes = ['OWID_WRL']
                const worldData = dataByCountry['OWID_WRL']
                const yKey = 'new_vaccinations_smoothed'

                // const worldData = dataset.filter(e => e.iso_code == 'OWID_WRL')
                // const usaData = dataset.filter(e => e.iso_code == 'USA')
                // const filteredData =
                // const data = usaData.map(d => d.)
                // Setting up X axis

                // Get the max country
                let maxCountry = getMaxCountryData(isoCodes, yKey)

                const data = dataByCountry[maxCountry]
                // console.log(data)

                var x = d3.scaleTime()
                    .domain(d3.extent(worldData, function (d) { return d.date; }))
                    .range([0, width]);
                var y1 = d3.scaleLinear()
                    .domain([0, d3.max(data, (d) => +(d[yKey]))])
                    .range([height, 0]);
                createChart({
                    chartWidth: width,
                    chartHeight: height,
                    data: data,
                    parentId: 'line2__chart__container',
                    xLabel: "Timeline of Covid 19",
                    y1Label: "New Vaccinations / Population",
                    xScale: x,
                    yScale: y1,
                    x: "date",
                    y: isoCodes,
                    chart1: ({ svg, id, i, xScale, yScale, x, y, chartMargin }) => {
                        const localData = dataByCountry[y[i]]
                        svg.append("path")
                            .attr('id', id)
                            .datum(localData)
                            .attr("fill", "none")
                            .attr("stroke", colorScale(i))
                            .attr("stroke-width", 1.5)
                            .attr("d", d3.line()
                                .x(function (d) { return xScale(d[x]) + chartMargin.left })
                                .y(function (d) { return yScale(d[yKey]) - chartMargin.bottom + chartMargin.top })
                            )
                    },
                })

            }

            const updateCountriesLineChart2 = async () => {
                const parentId = 'line2__chart__container';

                const svg = d3
                    .select(`#${parentId}__svg`)

                const charts = svg.selectAll('.chart');
                if (charts.size() == selectedCountries.length) {
                    updateLineChart2()
                    return;
                } else if (charts.size() > selectedCountries.length) {
                    let deleteNum = charts.size() - selectedCountries.length;
                    let deleteStart = selectedCountries.length
                    for (let i = deleteStart; i < deleteStart + deleteNum; i++) {
                        d3.select(`#${parentId}__chart${i}`).remove()
                    }
                } else {
                    let addNum = selectedCountries.length - charts.size()
                    let addStart = charts.size()
                    for (let i = addStart; i < addStart + addNum; i++) {
                        const localData = dataByCountry[selectedCountries[i]]
                        const marginLeft = d3.select(`#${parentId}__chart0`).attr('marginLeft')
                        const marginTop = d3.select(`#${parentId}__chart0`).attr('marginTop')
                        const marginBottom = d3.select(`#${parentId}__chart0`).attr('marginBottom')

                        svg.append("path")
                            .attr('id', `${parentId}__chart${i}`)
                            .attr('class', 'chart')
                            .attr('marginLeft', marginLeft)
                            .attr('marginTop', marginTop)
                            .attr('marginBottom', marginBottom)
                            .datum(localData)
                            .attr("fill", "none")
                            .attr("stroke", colorScale(i))
                            .attr("stroke-width", 1.5)
                        // .attr("d", d3.line()
                        //     .x(function (d) { return xScale(d[x]) + chartMargin.left })
                        //     .y(function (d) { return yScale(d[yKey]) - chartMargin.bottom + chartMargin.top })
                        // )
                    }
                }
                updateLineChart2()

            }

            const updateLineChart2 = async () => {
                const parentId = 'line2__chart__container';
                const isoCodes = selectedCountries.length == 0 ? ['OWID_WRL'] : selectedCountries;

                const worldData = dataByCountry['OWID_WRL']

                const svg = d3
                    .select(`#${parentId}__svg`)

                let height = parseFloat(svg.attr('viewHeight'))
                let width = parseFloat(svg.attr('viewWidth'))

                const selection = {
                    value1: d3.select(`#${parentId}__select1`).property('value'),
                    text1: d3.select(`#${parentId}__select1 option:checked`).text(),
                    value2: d3.select(`#${parentId}__select2`).property('value'),
                    text2: d3.select(`#${parentId}__select2 option:checked`).text(),
                }

                const getDivideBy = (d) => {
                    return d[selection.value2] ?? 1
                }
                // console.log('selectionValue1: ' + selection.value1)

                let maxCountry = getMaxCountryData(isoCodes, selection.value1, selection.value2)

                const data = dataByCountry[maxCountry]

                var xScale = d3.scaleTime()
                    .domain(d3.extent(worldData, function (d) { return d.date; }))
                    .range([0, width]);

                var yScale = d3.scaleLinear()
                    .domain([0, d3.max(data, (d) => +(d[selection.value1] / getDivideBy(d)))])
                    .range([height, 0]);

                svg
                    .select(`#${parentId}__y1__axis`)
                    .call(d3.axisLeft(yScale));

                const yLabel = `${selection.text1} ${selection.text2 != '1' ? `/ ${selection.text2}` : ''}`

                d3.select(`#${parentId}__y1label`).text(yLabel)

                const charts = svg.selectAll('.chart')
                // Update the charts
                for (let i = 0; i < charts.size(); i++) {
                    const chart = d3.select(`#${parentId}__chart${i}`)
                    const marginLeft = parseFloat(chart.attr('marginLeft'))
                    const marginTop = parseFloat(chart.attr('marginTop'))
                    const marginBottom = parseFloat(chart.attr('marginBottom'))

                    chart
                        .datum(dataByCountry[isoCodes[i]])
                        .attr("d", d3.line()
                            .x(function (d) { return xScale(d['date']) + marginLeft })
                            .y(function (d) { return yScale(d[selection.value1] / getDivideBy(d)) - marginBottom + marginTop; })
                        )


                }

                // Scatter GDP
            }

            const updateLineChart = () => {
                // Get Values from the change
                const line1SelectValue = d3.select('#line__select1').property('value')
                const line1SelectText = d3.select('#line__select1 option:checked').text()
                const line2SelectValue = d3.select('#line__select2').property('value')
                const line2SelectText = d3.select('#line__select2 option:checked').text()

                const svg = d3.select('#line__chart__container').select('svg')

                // get data
                const data = dataset.filter(e => e.iso_code == 'OWID_WRL')

                // Setting up right Y Axis
                var x = d3.scaleTime()
                    .domain(d3.extent(data, function (d) { return d.date; }))
                    .range([0, width]);
                // People Vaccinated
                var y1 = d3.scaleLinear()
                    .domain([0, d3.max(data, (d) => +d[line1SelectValue])])
                    .range([height, 0]);
                svg
                    .select('#line__chart__y1__axis')
                    .call(d3.axisLeft(y1));

                // New Cases
                var y2 = d3.scaleLinear()
                    .domain([0, d3.max(data, (d) => +d[line2SelectValue])])
                    .range([height, 0]);
                svg.select('#line__chart__y2__axis')
                    .call(d3.axisRight(y2));

                // Update Line1 Path
                svg.select("#line_path1")
                    .datum(data)
                    .attr("d", d3.line()
                        .x(function (d) { return x(d.date) + margin.left })
                        .y(function (d) { return y1(d[line1SelectValue]) + margin.top })
                    )

                svg.select("#line_path2")
                    .datum(data)
                    .attr("d", d3.line()
                        .x(function (d) { return x(d.date) + margin.left })
                        .y(function (d) { return y2(d[line2SelectValue]) + margin.top })
                    )


                svg.select(".y1_label")
                    .attr("x", -(300))
                    .attr("y", 20)
                    .attr('transform', `rotate(-90)`)
                    .text(`Number of ${line1SelectText}`);

                svg.select(".y2_label")
                    .attr("x", -(300))
                    .attr("y", width + margin.left + 120)
                    .attr('transform', `rotate(-90)`)
                    .text(`Number of ${line2SelectText}`);

            }


            // const createGdpChart = async () => {
            //     let data = getTotalsByCountry({ key: 'people_vaccinated' })
            //     data = data.filter(d => d.gdp > 0)
            //     const svg = d3
            //         .select('#scatter__chart__container')
            //         .append("svg")
            //         .attr("preserveAspectRatio", "xMinYMin meet")
            //         .attr("viewBox", `0 0 ${scatterContainerWidth} ${scatterContainerHeight}`)
            //         .append("g")
            //         .attr('transform', `translate(${scatterMargin.left}, ${scatterMargin.right})`)

            //     var x = d3.scaleLinear()
            //         .domain([d3.min(data, d => +d.gdp), d3.max(data, d => +d.gdp)])
            //         .range([0, scatterWidth])
            //     svg.append("g")
            //         .attr('id', 'scatter__x__axis')
            //         .attr("transform", "translate(0," + scatterHeight + ")")
            //         .call(d3.axisBottom(x));
            //     const maxY = d3.max(data, (d) => +(d.value / d.pop))
            //     var y = d3.scaleLinear()
            //         .domain([0, maxY])
            //         .range([scatterHeight, 0]);
            //     svg.append("g")
            //         .attr('id', 'scatter__y__axis')
            //         .call(d3.axisLeft(y));

            //     // Scatter GDP
            //     svg.append("g")
            //         .selectAll("dot")
            //         .data(data)
            //         .enter()
            //         .append("circle")
            //         .attr("cx", function (d) { return x(d.gdp); })
            //         .attr("cy", function (d) { return y(d.value / d.pop); })
            //         .attr("r", 2)
            //         .style("fill", "#69b3a2")

            // }

            const updateScatterPlot = () => {
                const value = d3.select("#scatter_select").property("value")
                const text = d3.select("#scatter_select option:checked").text()
                // console.log(`Text: ${text}`)
                let data = getTotalsByCountry({ key: value })
                data = data.filter(d => d.gdp > 0)
                let parentId = "#scatter__chart__container"

                const svg = d3
                    .select(`${parentId}__svg`)

                let height = parseFloat(svg.attr('viewHeight'))
                let width = parseFloat(svg.attr('viewWidth'))
                // console.log(`Width: ${width}, Height: ${height}`)

                var x = d3.scaleLinear()
                    .domain([0, d3.max(data, d => +d.gdp)])
                    .range([0, width])
                d3.select(`${parentId}__x__axis`)
                    .call(d3.axisBottom(x));
                const maxY = d3.max(data, (d) => +(d.value / d.pop))
                var y = d3.scaleLinear()
                    .domain([0, maxY])
                    .range([height, 0]);
                d3.select(`${parentId}__y__axis`)
                    .call(d3.axisLeft(y));

                // Update the X Label
                d3.select(`${parentId}__y1label`).text(text)

                const chart = d3.select(`${parentId}__chart0`)
                // Scatter GDP
                const marginLeft = parseFloat(chart.attr('marginLeft'))
                const marginTop = parseFloat(chart.attr('marginTop'))
                const marginBottom = parseFloat(chart.attr('marginBottom'))
                chart.selectAll("circle")
                    .data(data)
                    .attr("cx", function (d) { return x(d.gdp) + marginLeft; })
                    .attr("cy", function (d) { return y(d.value / d.pop) - marginBottom + marginTop; })
                    .attr("r", 2)
                    .style("fill", "#69b3a2")


            }

            // 
            createMap()
            d3.select("#map__select").on('change', onMapSelectChange)
            d3.select("#map__by__select").on('change', onMapSelectChange)
            createLineChart()
            d3.select("#line__select1").on('change', updateLineChart)
            d3.select("#line__select2").on('change', updateLineChart)
            createGdpChart()
            d3.select("#scatter_select").on('change', updateScatterPlot)
            createLineChart2()
            d3.select('#line2__chart__container__select1').on('change', updateLineChart2)
            d3.select('#line2__chart__container__select2').on('change', updateLineChart2)


        })()
    </script>
</body>

</html>